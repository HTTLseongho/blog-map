<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>seongho_vs_ai</title>
  <meta name="description" content="네이버 블로그 내부 링크를 Obsidian 그래프처럼 시각화" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #1a1a2e;
      font-family: 'Noto Sans KR', sans-serif;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    #graph-container {
      width: 100%;
      height: 100%;
      position: relative;
    }

    svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .link {
      stroke: rgba(139, 92, 246, 0.25);
      stroke-width: 1;
      transition: stroke 0.3s, stroke-width 0.3s;
    }

    .link.highlighted {
      stroke: rgba(139, 92, 246, 0.8);
      stroke-width: 2;
    }

    .node-circle {
      cursor: pointer;
      transition: r 0.3s ease;
    }

    .node-label {
      fill: #c4b5fd;
      font-size: 10px;
      font-weight: 400;
      pointer-events: none;
      text-anchor: middle;
      opacity: 0.85;
      transition: opacity 0.3s, font-size 0.3s;
      text-shadow: 0 0 6px rgba(26, 26, 46, 0.9), 0 0 12px rgba(26, 26, 46, 0.7);
    }

    .node-label.hub {
      font-size: 13px;
      font-weight: 700;
      fill: #e9d5ff;
      opacity: 1;
    }

    .node-label.dimmed { opacity: 0.15; }
    .node-circle.dimmed { opacity: 0.1; }
    .link.dimmed { opacity: 0.05; }

    .node-label.focused {
      opacity: 1;
      font-size: 13px;
      fill: #fff;
    }

    /* Legend */
    #legend {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(26, 26, 46, 0.85);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(139, 92, 246, 0.2);
      border-radius: 12px;
      padding: 16px 20px;
      color: #c4b5fd;
      font-size: 12px;
      z-index: 10;
    }

    #legend h3 {
      font-size: 14px;
      font-weight: 700;
      color: #e9d5ff;
      margin-bottom: 12px;
      letter-spacing: 0.5px;
    }

    #stats {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(26, 26, 46, 0.85);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(139, 92, 246, 0.2);
      border-radius: 12px;
      padding: 14px 18px;
      color: #94a3b8;
      font-size: 11px;
      z-index: 10;
    }

    #tooltip {
      position: absolute;
      background: rgba(30, 30, 60, 0.95);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(139, 92, 246, 0.4);
      border-radius: 8px;
      padding: 10px 14px;
      color: #e2e8f0;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 20;
      max-width: 300px;
    }

    #tooltip .tt-title {
      font-weight: 700;
      color: #e9d5ff;
      margin-bottom: 4px;
    }

    #tooltip .tt-meta {
      color: #94a3b8;
      font-size: 11px;
    }

    /* Loading / Error overlay */
    .overlay {
      position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
      background: rgba(26, 26, 46, 0.9); color: #c4b5fd; font-size: 14px; text-align: center; z-index: 9999;
      padding: 16px; line-height: 1.6;
    }
    .overlay.hidden { display: none; }
    .overlay strong { color: #e9d5ff; }
  </style>
</head>
<body>
<div id="graph-container">
  <svg id="graph"></svg>

  <div id="legend">
    <h3>seongho_vs_ai</h3>
    <div style="color:#94a3b8; line-height:1.6;">노드 크기 = 연결 수</div>
  </div>

  <div id="stats"></div>
  <div id="tooltip"></div>
</div>

<!-- Loading / Error -->
<div id="overlay" class="overlay">
  <div><strong>그래프 로딩 중...</strong></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
<script>
  const GRAPH_URL = 'graph.json';
  const NODE_COLOR = '#8b5cf6';
  const HUB_THRESHOLD = 5;

  /* Overlay helpers */
  const overlayEl = document.getElementById('overlay');
  const showOverlay = html => { overlayEl.innerHTML = html; overlayEl.classList.remove('hidden'); };
  const hideOverlay = () => overlayEl.classList.add('hidden');

  function getRadius(d) {
    return Math.max(4, Math.sqrt(d.linkCount) * 4);
  }

  async function loadGraph() {
    const res = await fetch(GRAPH_URL, { cache: 'no-store' });
    if (!res.ok) throw new Error(`graph.json 로드 실패 (HTTP ${res.status})`);
    return await res.json();
  }

  (async () => {
    try {
      const raw = await loadGraph();
      hideOverlay();

      const rawNodes = raw?.elements?.nodes ?? [];
      const rawEdges = raw?.elements?.edges ?? [];

      /* ── Convert Cytoscape format → D3 format ── */

      // Deduplicate edges (directed → undirected)
      const edgeSet = new Set();
      const links = [];
      for (const e of rawEdges) {
        const s = e?.data?.source, t = e?.data?.target;
        if (!s || !t || s === t) continue;
        const a = s < t ? s : t, b = s < t ? t : s;
        const key = `${a}|${b}`;
        if (!edgeSet.has(key)) {
          edgeSet.add(key);
          links.push({ source: a, target: b });
        }
      }

      // Count links per node
      const linkCountMap = new Map();
      for (const l of links) {
        linkCountMap.set(l.source, (linkCountMap.get(l.source) || 0) + 1);
        linkCountMap.set(l.target, (linkCountMap.get(l.target) || 0) + 1);
      }

      const nodes = rawNodes.map(n => ({
        id: n.data.id,
        label: n.data.label || n.data.id,
        url: n.data.url || '',
        linkCount: linkCountMap.get(n.data.id) || 0
      }));

      /* ── Stats ── */
      const statsEl = document.getElementById('stats');
      statsEl.textContent = `노트 ${nodes.length}개 · 링크 ${links.length}개`;

      /* ── D3 Force Graph ── */
      const svg = d3.select('#graph');
      const container = document.getElementById('graph-container');
      const width = container.clientWidth;
      const height = container.clientHeight;

      const g = svg.append('g');

      // Zoom
      const zoom = d3.zoom()
        .scaleExtent([0.3, 5])
        .on('zoom', (e) => g.attr('transform', e.transform));
      svg.call(zoom);

      // Initial centering
      svg.call(zoom.transform, d3.zoomIdentity.translate(width / 2, height / 2).scale(0.9));

      // Simulation
      const simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(d => {
          const sl = typeof d.source === 'object' ? d.source.linkCount : 0;
          const tl = typeof d.target === 'object' ? d.target.linkCount : 0;
          if (sl >= HUB_THRESHOLD || tl >= HUB_THRESHOLD) return 120;
          return 70;
        }))
        .force('charge', d3.forceManyBody().strength(d => d.linkCount >= HUB_THRESHOLD ? -400 : -150))
        .force('center', d3.forceCenter(0, 0))
        .force('collision', d3.forceCollide().radius(d => getRadius(d) + 15));

      // Links
      const link = g.append('g')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('class', 'link');

      // Nodes
      const node = g.append('g')
        .selectAll('circle')
        .data(nodes)
        .join('circle')
        .attr('class', 'node-circle')
        .attr('r', d => getRadius(d))
        .attr('fill', NODE_COLOR)
        .attr('stroke', 'rgba(255,255,255,0.1)')
        .attr('stroke-width', 1)
        .style('filter', d => d.linkCount >= HUB_THRESHOLD ? `drop-shadow(0 0 6px ${NODE_COLOR}55)` : 'none')
        .call(d3.drag()
          .on('start', dragstarted)
          .on('drag', dragged)
          .on('end', dragended));

      // Labels
      const label = g.append('g')
        .selectAll('text')
        .data(nodes)
        .join('text')
        .attr('class', d => 'node-label' + (d.linkCount >= HUB_THRESHOLD ? ' hub' : ''))
        .attr('dy', d => getRadius(d) + 14)
        .text(d => d.label);

      // Tooltip
      const tooltip = document.getElementById('tooltip');

      /* ── Interactions ── */

      // Hover: highlight neighbors, dim rest
      node.on('mouseover', function(event, d) {
        const connected = new Set();
        connected.add(d.id);
        links.forEach(l => {
          const sid = typeof l.source === 'object' ? l.source.id : l.source;
          const tid = typeof l.target === 'object' ? l.target.id : l.target;
          if (sid === d.id) connected.add(tid);
          if (tid === d.id) connected.add(sid);
        });

        node.classed('dimmed', n => !connected.has(n.id));
        label.classed('dimmed', n => !connected.has(n.id));
        label.classed('focused', n => n.id === d.id);
        link.classed('dimmed', l => {
          const sid = typeof l.source === 'object' ? l.source.id : l.source;
          const tid = typeof l.target === 'object' ? l.target.id : l.target;
          return !connected.has(sid) || !connected.has(tid);
        });
        link.classed('highlighted', l => {
          const sid = typeof l.source === 'object' ? l.source.id : l.source;
          const tid = typeof l.target === 'object' ? l.target.id : l.target;
          return (sid === d.id || tid === d.id);
        });

        d3.select(this).transition().duration(200).attr('r', getRadius(d) * 1.5);

        tooltip.style.opacity = 1;
        tooltip.innerHTML = `<div class="tt-title">${d.label}</div><div class="tt-meta">${d.linkCount}개 연결</div>`;
        tooltip.style.left = (event.pageX + 16) + 'px';
        tooltip.style.top = (event.pageY - 10) + 'px';
      });

      node.on('mousemove', function(event) {
        tooltip.style.left = (event.pageX + 16) + 'px';
        tooltip.style.top = (event.pageY - 10) + 'px';
      });

      node.on('mouseout', function(event, d) {
        node.classed('dimmed', false);
        label.classed('dimmed', false);
        label.classed('focused', false);
        link.classed('dimmed', false);
        link.classed('highlighted', false);
        d3.select(this).transition().duration(200).attr('r', getRadius(d));
        tooltip.style.opacity = 0;
      });

      // Click: open blog post in new tab
      node.on('click', function(event, d) {
        if (d.url) window.open(d.url, '_blank', 'noopener');
      });

      // Tick
      simulation.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);
        node
          .attr('cx', d => d.x)
          .attr('cy', d => d.y);
        label
          .attr('x', d => d.x)
          .attr('y', d => d.y);
      });

      // Drag
      function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x; d.fy = d.y;
      }
      function dragged(event, d) {
        d.fx = event.x; d.fy = event.y;
      }
      function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null; d.fy = null;
      }

    } catch (err) {
      showOverlay(
        `<div>
          <strong>그래프 로드 실패</strong><br/>
          ${String(err).replace(/[<>]/g, '')}<br/><br/>
          · <code>${GRAPH_URL}</code> 파일이 같은 폴더에 있는지 확인하세요.<br/>
          · 로컬은 <code>file://</code> 대신 <code>http://localhost:5500</code> 같은 간단 서버로 열어보세요.
        </div>`
      );
      console.error(err);
    }
  })();
</script>
</body>
</html>
